#!/usr/bin/env TclTaskRunner.tcl
# -*- mode: tcl -*-

#
# ./main.tcltask を実行した時に呼び出されるタスク(ALL)の宣言
#
default target ALL

#========================================

# このスクリプトの置かれたディレクトリを $self のメンバー変数へ保存
variable scriptDir [file dirname [info script]]

# オプション群。今は単なる定数の括りだし
# （コマンド行から一度限りでこれらをオーバーライドすることにどの程度メリットが？

option -variant-symbol jp_us
option -xkb-dir        /usr/share/X11/xkb
option -symbol-file    jp
option -rule           evdev

#========================================
# 以下、実際のタスク定義

#
# symbols/jp に jp_us の定義が無ければ加える
#
ALL depends target symbols check {
    expr {$options(-variant-symbol) in [$self list_xkb_symbols]}
} action {
    ** exec {*}[may-sudo] tee -a [$self symbol-file] < [$self symbol-source] \
         2>@ stderr
}

#
# rules/evdev.lst に jp_us の宣言が無ければ加える
#
ALL depends target rule-lst check {
    expr {$options(-variant-symbol) in [$self read-rule-list 1]}
} action {
    ** exec {*}[may-sudo] perl -i -nle {
        print;
        if (/^! variant/) {
            print q(  jp_us           jp: Japanese (JP106 with US));
        }
    } [$self rule-list-file] 2>@ stderr
}

#
# rules/evdev.xml に jp_us の宣言が無ければ加える
#

ALL depends target rule-xml dependsTasks xpath check {
    expr {$options(-variant-symbol) in [$self rule-xml-variant-list]}
} action {
    ** exec {*}[may-sudo] perl -i -0 -ne {
        s{(<layout>\s*<configItem>\s*<name>jp</name>.*?)(</variantList>)}{
            $1 . q{
         <variant>
           <configItem>
             <name>jp_us</name>
             <description>JP106 with US layout</description>
           </configItem>
         </variant>
            } . $2
        }es;
        print;
    } [$self rule-xml-file] 2>@ stderr
}


#----------------------------------------
# 全/半 キーを Grave(`)/AsciiTilde(~) に戻すオプション
#----------------------------------------

ALL depends target {hztg_grave_tilde symbol} check {
    expr {[lindex $target 0] in [$self list_xkb_symbols]}
} action {
    ** exec {*}[may-sudo] tee -a [$self symbol-file] \
        < [$self symbol-source [lindex $target 0]] \
         2>@ stderr
}

#
# rules/evdev.lst に japan:hztg_grave_tilde オプションが無ければ加える
#

ALL depends target {hztg_grave_tilde option-list} check {
    expr {[lindex $target 0] in [dict get [$self read-rule-option-dict] japan]}
} action {
    $self append-rule-list-option \
        japan:[lindex $target 0] "Make Zenkaku Hankaku an additional Grave"
}

#
# rules/evdev.xml に japan:hztg_grave_tilde オプションが無ければ加える
#

ALL depends target {hztg_grave_tilde option-xml} dependsTasks xpath check {
    expr {[lindex $target 0] in [$self rule-xml-option-list]}
} action {
    $self append-rule-xml-option \
        japan:[lindex $target 0] "Make Zenkaku Hankaku an additional Grave"
}

#========================================

#
# xpath コマンドが無ければインストールする
#
target xpath check {
    expr {[auto_execok $target] ne "" || [file executable $target]}
} action {
    ** exec {*}[may-sudo] dnf install -y /usr/bin/$target
}

#========================================
# 以下、下請けメソッド。コマンド行からサブコマンドとして呼び出し可能
#========================================

method read-rule-list {{keysOnly no}} {
    set ls [exec perl -nle {
        next unless /^! variant/ .. /^\s*$/;
        my @kv = /^\s*(\S+)\s+jp: (.*)/ or next;
        print join "\t", @kv
    } [$self rule-list-file]]

    if {$keysOnly} {
        lmap i [split $ls \n] {lindex $i 0}
    } else {
        return $ls
    }
}

# ./main.tcltask -n append-rule-list-option japan:hztg_grave_tilde "Make Zenkaku Hankaku an additional Grave"

method append-rule-list-option {groupItem title} {
    lassign [split $groupItem :] groupName _optionName

    set opts [if {![IS_DRY_RUN]} {list -i}]

    set map [list @GROUP@ $groupName @ITEM@ $groupItem @TITLE@ $title]

    set cmd [list {*}[may-sudo] perl {*}$opts -ple [string map $map {
        next unless (/^! option/ .. (/^\s*$/ || eof));
        my $groupLine = /^\s+@GROUP@:/ .. /^\s+(?!@GROUP@)\w+/;
        if ($groupLine =~ /E0/) {
            # print STDERR "# ($groupLine) $_";
            print "  @ITEM@    @TITLE@";
        }
    }] [$self rule-list-file]]

    puts "# $cmd"

    exec {*}$cmd >@ stdout 2>@ stderr
}

method append-rule-xml-option {groupItem title} {
    lassign [split $groupItem :] groupName _optionName

    set opts [if {![IS_DRY_RUN]} {list -i}]

    set map [list @GROUP@ $groupName @ITEM@ $groupItem @TITLE@ $title]

    set cmd [list {*}[may-sudo] perl {*}$opts -0 -ne [string map $map {
        s{(<group[^>]*>\s*<configItem>\s*<name>@GROUP@</name>.*?)(</group>)}{
            $1 . q{
      <option>
        <configItem>
          <name>@ITEM@</name>
          <description>@TITLE@</description>
        </configItem>
      </option>
    } . $2}es;
        print;
    }] [$self rule-xml-file]]

    puts "# $cmd"

    exec {*}$cmd >@ stdout 2>@ stderr
}

method read-rule-option-dict {} {
    set dict []
    foreach item [$self read-rule-option-list] {
        incr lineNo
        if {[regexp {^([^:]+):(.*)} $item -> group opt]} {
            dict lappend dict $group $opt
        }
    }
    set dict
}

method read-rule-option-list {} {
    exec perl -nle {
        next unless /^! option/ .. /^\s*$/;
        my ($item) = /^\s*(\S+)/ or next;
        print $item
    } [$self rule-list-file]
}

method rule-list-file {} {
    return $options(-xkb-dir)/rules/$options(-rule).lst
}

method rule-xml-variant-list {{lang "jp"}} {
    exec xpath -q -e [string map [list @LANG@ $lang] {
        //layout/configItem/name[text() = "@LANG@"]/parent::node()/parent::node()/variantList/variant/configItem/name/text()
    }] [$self rule-xml-file]
}

method rule-xml-option-list {{group "japan"}} {
    set output [exec xpath -q -e [string map [list @GROUP@ $group] {
        //group/configItem/name[text() = "@GROUP@"]/parent::node()/parent::node()/option/configItem/name/text()
    }] [$self rule-xml-file]]

    regsub -all -line ^$group: $output {}
}

method rule-xml-file {} {
    return $options(-xkb-dir)/rules/$options(-rule).xml
}

method symbol-source {{target ""}} {
    if {$target eq ""} {
        set target $options(-variant-symbol)
    }
    return $scriptDir/symbols/$target
}

method symbol-file {{target ""}} {
    if {$target eq ""} {
        set target $options(-symbol-file)
    }
    return $options(-xkb-dir)/symbols/$target
}

method list_xkb_symbols {args} {
    if {$args eq ""} {
        lappend args [$self symbol-file]
    }
    exec perl -nle {m{^xkb_symbols\s+\"([^\"]+)\"} and print $1} {*}$args
}

#========================================
# 以下、下請け手続き
# こちらはコマンド行から直接呼び出す手段は（現状）存在しない
# 代わりに、$self 抜きで呼び出し可能

proc may-sudo {} {
    if {[exec id -u] != 0} {
        list sudo
    }
}
